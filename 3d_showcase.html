<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>3D Boss Animation Showcase</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #000; overflow: hidden; font-family: monospace; }
canvas { display: block; }
#ui {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; z-index: 10;
}
#dialogue {
  position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%);
  width: 80%; max-width: 700px; background: rgba(0,0,0,0.85);
  border: 2px solid #ff4400; border-radius: 8px; padding: 20px 24px;
  color: #fff; font-size: 16px; line-height: 1.5; z-index: 20;
  display: none; pointer-events: auto;
  box-shadow: 0 0 30px rgba(255,68,0,0.3), inset 0 0 60px rgba(255,68,0,0.05);
}
#dialogue .speaker {
  color: #ff4400; font-weight: bold; font-size: 18px; margin-bottom: 6px;
  text-shadow: 0 0 10px #ff440088;
}
#dialogue .text { color: #ddd; min-height: 40px; }
#dialogue .hint {
  color: #666; font-size: 11px; text-align: right; margin-top: 8px;
}
#info {
  position: fixed; top: 15px; left: 50%; transform: translateX(-50%);
  color: #888; font-size: 12px; z-index: 20; text-align: center;
  pointer-events: auto;
}
#restart {
  position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
  background: #ff440022; border: 1px solid #ff440066; color: #ff8844;
  padding: 8px 20px; cursor: pointer; font-family: monospace; font-size: 13px;
  border-radius: 4px; z-index: 20; display: none; pointer-events: auto;
}
#restart:hover { background: #ff440044; }
</style>
</head>
<body>
<div id="info">3D BOSS ENTRANCE SHOWCASE — Click anywhere to advance dialogue</div>
<button id="restart" onclick="restartDemo()">▶ REPLAY</button>
<div id="dialogue">
  <div class="speaker" id="dSpeaker"></div>
  <div class="text" id="dText"></div>
  <div class="hint">Click to continue...</div>
</div>

<script type="importmap">
{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" } }
</script>
<script type="module">
import * as THREE from 'three';

// ── SCENE SETUP ──
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.012);

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
camera.position.set(0, 8, 25);
camera.lookAt(0, 2, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 0.8;
document.body.appendChild(renderer.domElement);

// ── ARENA FLOOR ──
const floorGeo = new THREE.PlaneGeometry(80, 80, 40, 40);
// Displace vertices for rocky terrain
const posAttr = floorGeo.attributes.position;
for (let i = 0; i < posAttr.count; i++) {
  const x = posAttr.getX(i), y = posAttr.getY(i);
  const dist = Math.sqrt(x*x + y*y);
  posAttr.setZ(i, Math.sin(x*0.5)*Math.cos(y*0.3)*0.4 - dist*0.02);
}
floorGeo.computeVertexNormals();
const floorMat = new THREE.MeshStandardMaterial({
  color: 0x1a1a2e, roughness: 0.9, metalness: 0.1,
});
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

// Grid lines on floor
const gridHelper = new THREE.GridHelper(60, 30, 0x222244, 0x111122);
gridHelper.position.y = 0.02;
scene.add(gridHelper);

// ── PILLARS ──
const pillarGeo = new THREE.CylinderGeometry(0.6, 0.8, 12, 8);
const pillarMat = new THREE.MeshStandardMaterial({ color: 0x2a1a0e, roughness: 0.7, metalness: 0.3 });
const pillarPositions = [[-10, 6, -8], [10, 6, -8], [-10, 6, 8], [10, 6, 8], [-6, 6, -12], [6, 6, -12]];
for (const [px, py, pz] of pillarPositions) {
  const p = new THREE.Mesh(pillarGeo, pillarMat);
  p.position.set(px, py, pz);
  p.castShadow = true;
  p.receiveShadow = true;
  scene.add(p);
  // Pillar top flame
  const flameLight = new THREE.PointLight(0xff6622, 2, 15);
  flameLight.position.set(px, py + 7, pz);
  scene.add(flameLight);
}

// ── BOSS PLATFORM ──
const platGeo = new THREE.CylinderGeometry(3, 3.5, 1.5, 6);
const platMat = new THREE.MeshStandardMaterial({ color: 0x331100, roughness: 0.5, metalness: 0.6 });
const platform = new THREE.Mesh(platGeo, platMat);
platform.position.set(0, 0.5, -5);
platform.castShadow = true;
platform.receiveShadow = true;
scene.add(platform);

// ── BOSS FIGURE (geometric humanoid) ──
const bossGroup = new THREE.Group();
bossGroup.position.set(0, -10, -5); // starts below ground
bossGroup.visible = false;

// Torso
const torsoGeo = new THREE.BoxGeometry(2.2, 3, 1.2);
const bossMat = new THREE.MeshStandardMaterial({ color: 0x1a1a3a, roughness: 0.4, metalness: 0.7 });
const torso = new THREE.Mesh(torsoGeo, bossMat);
torso.position.y = 5;
torso.castShadow = true;
bossGroup.add(torso);

// Head
const headGeo = new THREE.SphereGeometry(0.8, 16, 16);
const headMat = new THREE.MeshStandardMaterial({ color: 0xcc9966, roughness: 0.6, metalness: 0.2 });
const head = new THREE.Mesh(headGeo, headMat);
head.position.y = 7.2;
head.castShadow = true;
bossGroup.add(head);

// Eyes (glowing)
const eyeGeo = new THREE.SphereGeometry(0.15, 8, 8);
const eyeMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 3 });
const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
eyeL.position.set(-0.3, 7.3, 0.65);
bossGroup.add(eyeL);
const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
eyeR.position.set(0.3, 7.3, 0.65);
bossGroup.add(eyeR);

// Crown
const crownGeo = new THREE.ConeGeometry(0.9, 1.2, 5);
const crownMat = new THREE.MeshStandardMaterial({ color: 0xffcc00, roughness: 0.2, metalness: 0.9, emissive: 0x442200, emissiveIntensity: 0.5 });
const crown = new THREE.Mesh(crownGeo, crownMat);
crown.position.y = 8.3;
crown.castShadow = true;
bossGroup.add(crown);

// Arms
const armGeo = new THREE.BoxGeometry(0.6, 2.5, 0.6);
const armL = new THREE.Mesh(armGeo, bossMat);
armL.position.set(-1.6, 4.5, 0);
armL.rotation.z = 0.2;
bossGroup.add(armL);
const armR = new THREE.Mesh(armGeo, bossMat);
armR.position.set(1.6, 4.5, 0);
armR.rotation.z = -0.2;
bossGroup.add(armR);

// Cape
const capeGeo = new THREE.PlaneGeometry(3, 4, 8, 8);
const capeMat = new THREE.MeshStandardMaterial({
  color: 0x880000, roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide
});
const cape = new THREE.Mesh(capeGeo, capeMat);
cape.position.set(0, 4, -0.8);
bossGroup.add(cape);

// Boss energy aura (ring)
const auraGeo = new THREE.TorusGeometry(2.5, 0.15, 16, 32);
const auraMat = new THREE.MeshStandardMaterial({ color: 0xff4400, emissive: 0xff2200, emissiveIntensity: 2, transparent: true, opacity: 0 });
const aura = new THREE.Mesh(auraGeo, auraMat);
aura.position.y = 4;
aura.rotation.x = Math.PI / 2;
bossGroup.add(aura);

// Second aura ring
const aura2Geo = new THREE.TorusGeometry(3.5, 0.1, 16, 32);
const aura2Mat = new THREE.MeshStandardMaterial({ color: 0xff8800, emissive: 0xff4400, emissiveIntensity: 2, transparent: true, opacity: 0 });
const aura2 = new THREE.Mesh(aura2Geo, aura2Mat);
aura2.position.y = 4;
aura2.rotation.x = Math.PI / 2;
bossGroup.add(aura2);

scene.add(bossGroup);

// Boss point light
const bossLight = new THREE.PointLight(0xff4400, 0, 20);
bossLight.position.set(0, 8, -5);
bossLight.castShadow = true;
scene.add(bossLight);

// ── PARTICLES SYSTEM ──
const PARTICLE_COUNT = 800;
const particlesGeo = new THREE.BufferGeometry();
const pPositions = new Float32Array(PARTICLE_COUNT * 3);
const pColors = new Float32Array(PARTICLE_COUNT * 3);
const pSizes = new Float32Array(PARTICLE_COUNT);
const pVelocities = [];
for (let i = 0; i < PARTICLE_COUNT; i++) {
  pPositions[i*3] = (Math.random()-0.5) * 60;
  pPositions[i*3+1] = Math.random() * 20;
  pPositions[i*3+2] = (Math.random()-0.5) * 60;
  pColors[i*3] = 0.3 + Math.random() * 0.7;
  pColors[i*3+1] = 0.1 + Math.random() * 0.3;
  pColors[i*3+2] = Math.random() * 0.1;
  pSizes[i] = 0.5 + Math.random() * 2;
  pVelocities.push({ x: (Math.random()-0.5)*0.02, y: 0.01 + Math.random()*0.03, z: (Math.random()-0.5)*0.02 });
}
particlesGeo.setAttribute('position', new THREE.BufferAttribute(pPositions, 3));
particlesGeo.setAttribute('color', new THREE.BufferAttribute(pColors, 3));
particlesGeo.setAttribute('size', new THREE.BufferAttribute(pSizes, 1));

const particleMat = new THREE.PointsMaterial({
  size: 0.3, vertexColors: true, transparent: true, opacity: 0.6,
  blending: THREE.AdditiveBlending, depthWrite: false,
});
const particleSystem = new THREE.Points(particlesGeo, particleMat);
scene.add(particleSystem);

// ── LIGHTNING BOLTS ──
const lightningBolts = [];
function createLightning(start, end, color = 0x4488ff) {
  const points = [start.clone()];
  const segments = 8;
  for (let i = 1; i < segments; i++) {
    const t = i / segments;
    const p = new THREE.Vector3().lerpVectors(start, end, t);
    p.x += (Math.random() - 0.5) * 3;
    p.y += (Math.random() - 0.5) * 2;
    p.z += (Math.random() - 0.5) * 3;
    points.push(p);
  }
  points.push(end.clone());
  const geo = new THREE.BufferGeometry().setFromPoints(points);
  const mat = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 1, linewidth: 2 });
  const bolt = new THREE.Line(geo, mat);
  bolt.userData = { life: 15, maxLife: 15 };
  scene.add(bolt);
  lightningBolts.push(bolt);
  return bolt;
}

// ── SHOCKWAVE RINGS ──
const shockwaves = [];
function createShockwave(y, color = 0xff4400) {
  const geo = new THREE.RingGeometry(0.1, 0.5, 32);
  const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
  const ring = new THREE.Mesh(geo, mat);
  ring.rotation.x = -Math.PI / 2;
  ring.position.set(0, y, -5);
  ring.userData = { life: 60, maxLife: 60, speed: 0.4 };
  scene.add(ring);
  shockwaves.push(ring);
}

// ── LIGHTING ──
const ambientLight = new THREE.AmbientLight(0x111122, 0.5);
scene.add(ambientLight);

const mainLight = new THREE.DirectionalLight(0x4444aa, 0.3);
mainLight.position.set(5, 15, 10);
mainLight.castShadow = true;
mainLight.shadow.mapSize.set(2048, 2048);
scene.add(mainLight);

// Dramatic red spot
const spotLight = new THREE.SpotLight(0xff2200, 0, 40, Math.PI * 0.3, 0.5, 2);
spotLight.position.set(0, 20, -5);
spotLight.target.position.set(0, 0, -5);
spotLight.castShadow = true;
scene.add(spotLight);
scene.add(spotLight.target);

// ── ANIMATION STATE ──
let time = 0;
let phase = 0; // 0=idle, 1=rumble, 2=rise, 3=reveal, 4=idle_boss, 5=dialogue
let phaseTimer = 0;
let shakeIntensity = 0;
let dialogueIndex = -1;
let typewriterText = '';
let typewriterTarget = '';
let typewriterTimer = 0;
let dialogueSpeaker = '';
let demoComplete = false;

const dialogueLines = [
  { speaker: '???', text: 'You dare approach my domain?', pause: 0 },
  { speaker: '???', text: 'I have watched you struggle... crawling over that pathetic wall...', pause: 0 },
  { speaker: 'THE OVERSEER', text: 'I am the one who BUILT the wall. Every brick. Every barbed wire.', pause: 0 },
  { speaker: 'THE OVERSEER', text: 'And now you stand before me, thinking your journey is almost over?', pause: 0 },
  { speaker: 'THE OVERSEER', text: 'How... AMUSING.', pause: 0 },
  { speaker: 'THE OVERSEER', text: 'Let me show you what REAL power looks like.', pause: 0 },
];

const dialogueEl = document.getElementById('dialogue');
const dSpeaker = document.getElementById('dSpeaker');
const dText = document.getElementById('dText');
const restartBtn = document.getElementById('restart');

// ── PHASE TRANSITIONS ──
function startPhase(p) {
  phase = p;
  phaseTimer = 0;
}

// ── CLICK HANDLER ──
document.addEventListener('click', () => {
  if (demoComplete) return;
  if (phase === 5) {
    // Advance dialogue
    if (typewriterText.length < typewriterTarget.length) {
      typewriterText = typewriterTarget; // skip typewriter
      return;
    }
    dialogueIndex++;
    if (dialogueIndex < dialogueLines.length) {
      showDialogue(dialogueLines[dialogueIndex]);
    } else {
      // End dialogue — boss power-up
      dialogueEl.style.display = 'none';
      startPhase(6);
    }
  }
});

function showDialogue(line) {
  dialogueSpeaker = line.speaker;
  typewriterTarget = line.text;
  typewriterText = '';
  typewriterTimer = 0;
  dSpeaker.textContent = line.speaker;
  dText.textContent = '';
  dialogueEl.style.display = 'block';
  dialogueEl.style.borderColor = line.speaker === '???' ? '#4488ff' : '#ff4400';
  dialogueEl.style.boxShadow = line.speaker === '???' ?
    '0 0 30px rgba(68,136,255,0.3), inset 0 0 60px rgba(68,136,255,0.05)' :
    '0 0 30px rgba(255,68,0,0.3), inset 0 0 60px rgba(255,68,0,0.05)';
  dSpeaker.style.color = line.speaker === '???' ? '#4488ff' : '#ff4400';
  dSpeaker.style.textShadow = line.speaker === '???' ? '0 0 10px #4488ff88' : '0 0 10px #ff440088';
}

// ── MAIN LOOP ──
function animate() {
  requestAnimationFrame(animate);
  time += 0.016;
  phaseTimer++;

  // ── PHASE 0: CALM (0-120 frames) ──
  if (phase === 0) {
    camera.position.x = Math.sin(time * 0.3) * 2;
    camera.position.y = 8 + Math.sin(time * 0.5) * 0.5;
    camera.position.z = 25;
    camera.lookAt(0, 2, 0);
    if (phaseTimer > 120) startPhase(1);
  }

  // ── PHASE 1: RUMBLE (120-240) ──
  if (phase === 1) {
    const prog = phaseTimer / 180;
    shakeIntensity = prog * 0.3;
    // Camera slowly pushes in
    camera.position.z = 25 - prog * 5;
    camera.position.y = 8 - prog * 2;
    camera.lookAt(0, 2, 0);
    // Floor vibrates
    floor.position.y = Math.sin(time * 20) * shakeIntensity * 0.1;
    // Red light builds
    spotLight.intensity = prog * 5;
    // Cracks — lightning from ground
    if (phaseTimer % 20 === 0 && phaseTimer > 60) {
      const angle = Math.random() * Math.PI * 2;
      const dist = 2 + Math.random() * 4;
      createLightning(
        new THREE.Vector3(Math.cos(angle) * dist, 0, -5 + Math.sin(angle) * dist),
        new THREE.Vector3(Math.cos(angle) * 0.5, 4 + Math.random() * 3, -5 + Math.sin(angle) * 0.5),
        0xff4400
      );
    }
    if (phaseTimer > 180) startPhase(2);
  }

  // ── PHASE 2: BOSS RISES (240-420) ──
  if (phase === 2) {
    const prog = Math.min(1, phaseTimer / 180);
    const easedProg = 1 - Math.pow(1 - prog, 3); // ease out cubic
    bossGroup.visible = true;
    bossGroup.position.y = -10 + easedProg * 11.5; // rise from -10 to 1.5
    bossGroup.rotation.y = easedProg * Math.PI * 2; // full spin during rise
    // Intense shake
    shakeIntensity = 0.3 + prog * 0.5;
    // Boss light grows
    bossLight.intensity = prog * 8;
    // Camera dramatic
    camera.position.z = 20 - prog * 5;
    camera.position.y = 6 + Math.sin(prog * Math.PI) * 3;
    camera.lookAt(0, 3 + easedProg * 3, -5);
    // Shockwaves
    if (phaseTimer % 30 === 0) createShockwave(0.5 + easedProg * 2);
    // More lightning
    if (phaseTimer % 10 === 0) {
      createLightning(
        new THREE.Vector3((Math.random()-0.5)*8, 0, -5 + (Math.random()-0.5)*8),
        new THREE.Vector3((Math.random()-0.5)*2, 6 + Math.random()*4, -5 + (Math.random()-0.5)*2),
        phaseTimer % 20 === 0 ? 0xff8800 : 0xff2200
      );
    }
    // Aura rings appear
    auraMat.opacity = prog * 0.7;
    aura2Mat.opacity = prog * 0.5;
    if (phaseTimer > 180) startPhase(3);
  }

  // ── PHASE 3: REVEAL — camera swoops (420-540) ──
  if (phase === 3) {
    const prog = Math.min(1, phaseTimer / 120);
    const easedProg = prog < 0.5 ? 2*prog*prog : 1 - Math.pow(-2*prog+2, 2)/2;
    shakeIntensity *= 0.95;
    // Camera swoops around to front
    const angle = Math.PI + easedProg * Math.PI;
    camera.position.x = Math.sin(angle) * 12;
    camera.position.z = -5 + Math.cos(angle) * 12;
    camera.position.y = 4 + (1 - easedProg) * 4;
    camera.lookAt(0, 6, -5);
    bossGroup.rotation.y += 0.01;
    // Flash at midpoint
    if (phaseTimer === 60) {
      shakeIntensity = 1;
      spotLight.intensity = 20;
      for (let i = 0; i < 5; i++) createShockwave(3);
    }
    spotLight.intensity = Math.max(3, spotLight.intensity * 0.97);
    if (phaseTimer > 120) startPhase(4);
  }

  // ── PHASE 4: IDLE BOSS (brief pause, then dialogue) ──
  if (phase === 4) {
    // Camera settles to dialogue position
    const prog = Math.min(1, phaseTimer / 60);
    camera.position.x += (3 - camera.position.x) * 0.05;
    camera.position.y += (5 - camera.position.y) * 0.05;
    camera.position.z += (8 - camera.position.z) * 0.05;
    camera.lookAt(0, 5.5, -5);
    shakeIntensity *= 0.9;
    if (phaseTimer > 90) {
      dialogueIndex = 0;
      showDialogue(dialogueLines[0]);
      startPhase(5);
    }
  }

  // ── PHASE 5: DIALOGUE ──
  if (phase === 5) {
    // Gentle camera sway
    camera.position.x = 3 + Math.sin(time * 0.4) * 0.5;
    camera.position.y = 5 + Math.sin(time * 0.3) * 0.3;
    camera.lookAt(0, 5.5, -5);
    // Typewriter effect
    typewriterTimer++;
    if (typewriterTimer % 2 === 0 && typewriterText.length < typewriterTarget.length) {
      typewriterText += typewriterTarget[typewriterText.length];
      dText.textContent = typewriterText;
    }
    // Boss subtle movement during dialogue
    if (dialogueSpeaker === 'THE OVERSEER') {
      bossGroup.children.forEach(c => {
        if (c === armR) c.rotation.z = -0.2 + Math.sin(time * 3) * 0.15;
      });
      // Occasional lightning emphasis
      if (phaseTimer % 90 === 0) {
        createLightning(
          new THREE.Vector3((Math.random()-0.5)*6, 8, -5 + (Math.random()-0.5)*6),
          new THREE.Vector3(0, 6, -5), 0xff4400
        );
        shakeIntensity = 0.15;
      }
    }
  }

  // ── PHASE 6: POWER UP FINALE ──
  if (phase === 6) {
    const prog = Math.min(1, phaseTimer / 240);
    // Camera pulls back dramatically
    camera.position.z = 8 + prog * 15;
    camera.position.y = 5 + prog * 5;
    camera.lookAt(0, 4, -5);
    // Boss ascends and powers up
    bossGroup.position.y = 1.5 + prog * 4;
    bossGroup.rotation.y += 0.03 + prog * 0.05;
    // Aura grows intense
    auraMat.opacity = 0.7 + prog * 0.3;
    aura.scale.setScalar(1 + prog * 2);
    aura2Mat.opacity = 0.5 + prog * 0.3;
    aura2.scale.setScalar(1 + prog * 1.5);
    // Eyes blaze
    eyeMat.emissiveIntensity = 3 + prog * 10;
    // Crown glows
    crownMat.emissiveIntensity = 0.5 + prog * 3;
    // Light explosion
    bossLight.intensity = 8 + prog * 20;
    spotLight.intensity = 3 + prog * 15;
    // Shake builds
    shakeIntensity = prog * 0.8;
    // Constant lightning
    if (phaseTimer % 5 === 0) {
      const a = Math.random() * Math.PI * 2;
      const d = 3 + Math.random() * 8;
      createLightning(
        new THREE.Vector3(Math.cos(a)*d, Math.random()*12, -5 + Math.sin(a)*d),
        new THREE.Vector3((Math.random()-0.5)*2, 5 + bossGroup.position.y, -5),
        Math.random() > 0.5 ? 0xff4400 : 0xffcc00
      );
    }
    // Shockwaves
    if (phaseTimer % 15 === 0) createShockwave(bossGroup.position.y);
    // Particles rush inward
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      const dx = -pPositions[i*3];
      const dy = 5 - pPositions[i*3+1];
      const dz = -5 - pPositions[i*3+2];
      pPositions[i*3] += dx * 0.005 * prog;
      pPositions[i*3+1] += dy * 0.005 * prog;
      pPositions[i*3+2] += dz * 0.005 * prog;
    }

    if (phaseTimer > 240) {
      startPhase(7);
      // Final flash
      spotLight.intensity = 50;
      bossLight.intensity = 50;
      shakeIntensity = 2;
      for (let i = 0; i < 10; i++) createShockwave(bossGroup.position.y);
    }
  }

  // ── PHASE 7: FADE / END ──
  if (phase === 7) {
    spotLight.intensity *= 0.95;
    bossLight.intensity *= 0.95;
    shakeIntensity *= 0.93;
    bossGroup.rotation.y += 0.02;
    // Camera slowly pulls back
    camera.position.z += 0.05;
    camera.lookAt(0, 5, -5);
    if (phaseTimer > 120 && !demoComplete) {
      demoComplete = true;
      restartBtn.style.display = 'block';
    }
  }

  // ── ALWAYS: Boss idle animations ──
  if (bossGroup.visible) {
    // Floating bob
    const baseY = bossGroup.position.y;
    // Cape flutter
    const capePos = cape.geometry.attributes.position;
    for (let i = 0; i < capePos.count; i++) {
      const y = capePos.getY(i);
      capePos.setZ(i, Math.sin(time * 3 + y * 2) * 0.3 * (1 + Math.abs(y) * 0.3));
    }
    capePos.needsUpdate = true;
    // Aura rotation
    aura.rotation.z = time * 2;
    aura2.rotation.z = -time * 1.5;
    // Eye pulsing
    if (phase >= 4) {
      const pulse = Math.sin(time * 4) * 0.5 + 0.5;
      eyeMat.emissiveIntensity = 3 + pulse * 3;
    }
  }

  // ── ALWAYS: Update particles ──
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    pPositions[i*3] += pVelocities[i].x;
    pPositions[i*3+1] += pVelocities[i].y;
    pPositions[i*3+2] += pVelocities[i].z;
    if (pPositions[i*3+1] > 20) {
      pPositions[i*3] = (Math.random()-0.5) * 60;
      pPositions[i*3+1] = 0;
      pPositions[i*3+2] = (Math.random()-0.5) * 60;
    }
  }
  particlesGeo.attributes.position.needsUpdate = true;

  // ── ALWAYS: Update lightning ──
  for (let i = lightningBolts.length - 1; i >= 0; i--) {
    const bolt = lightningBolts[i];
    bolt.userData.life--;
    bolt.material.opacity = bolt.userData.life / bolt.userData.maxLife;
    if (bolt.userData.life <= 0) {
      scene.remove(bolt);
      bolt.geometry.dispose();
      bolt.material.dispose();
      lightningBolts.splice(i, 1);
    }
  }

  // ── ALWAYS: Update shockwaves ──
  for (let i = shockwaves.length - 1; i >= 0; i--) {
    const sw = shockwaves[i];
    sw.userData.life--;
    const prog = 1 - sw.userData.life / sw.userData.maxLife;
    sw.scale.setScalar(1 + prog * 20);
    sw.material.opacity = (1 - prog) * 0.6;
    if (sw.userData.life <= 0) {
      scene.remove(sw);
      sw.geometry.dispose();
      sw.material.dispose();
      shockwaves.splice(i, 1);
    }
  }

  // ── ALWAYS: Pillar flame flicker ──
  scene.children.forEach(c => {
    if (c instanceof THREE.PointLight && c !== bossLight && c !== spotLight) {
      c.intensity = 1.5 + Math.sin(time * 10 + c.position.x) * 0.8;
    }
  });

  // ── Camera shake ──
  if (shakeIntensity > 0.01) {
    camera.position.x += (Math.random() - 0.5) * shakeIntensity;
    camera.position.y += (Math.random() - 0.5) * shakeIntensity * 0.5;
  }

  renderer.render(scene, camera);
}

// ── RESTART ──
window.restartDemo = function() {
  time = 0;
  phase = 0;
  phaseTimer = 0;
  shakeIntensity = 0;
  dialogueIndex = -1;
  typewriterText = '';
  typewriterTarget = '';
  dialogueSpeaker = '';
  demoComplete = false;
  bossGroup.visible = false;
  bossGroup.position.y = -10;
  bossGroup.rotation.y = 0;
  bossLight.intensity = 0;
  spotLight.intensity = 0;
  auraMat.opacity = 0;
  aura2Mat.opacity = 0;
  aura.scale.setScalar(1);
  aura2.scale.setScalar(1);
  eyeMat.emissiveIntensity = 3;
  crownMat.emissiveIntensity = 0.5;
  dialogueEl.style.display = 'none';
  restartBtn.style.display = 'none';
  camera.position.set(0, 8, 25);
  // Reset particles
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    pPositions[i*3] = (Math.random()-0.5) * 60;
    pPositions[i*3+1] = Math.random() * 20;
    pPositions[i*3+2] = (Math.random()-0.5) * 60;
  }
  // Clear effects
  for (const b of lightningBolts) { scene.remove(b); b.geometry.dispose(); b.material.dispose(); }
  lightningBolts.length = 0;
  for (const s of shockwaves) { scene.remove(s); s.geometry.dispose(); s.material.dispose(); }
  shockwaves.length = 0;
};

// ── RESIZE ──
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

animate();
</script>
</body>
</html>
