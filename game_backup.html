<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Wall Jumper - Escape!</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #111;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  font-family: 'Segoe UI', Arial, sans-serif;
  overflow: hidden;
}
canvas {
  border: 2px solid #444;
  border-radius: 4px;
  image-rendering: pixelated;
}
#ui {
  color: #ccc;
  text-align: center;
  margin-bottom: 10px;
}
#ui h1 { font-size: 22px; color: #f0c040; letter-spacing: 2px; }
#ui p { font-size: 13px; color: #999; margin-top: 4px; }
</style>
</head>
<body>
<div id="ui">
  <h1>WALL JUMPER — ESCAPE!</h1>
  <p>Arrow Keys / WASD to move &amp; jump · Dodge guards · Climb the big wall to escape!</p>
</div>
<canvas id="game" width="1000" height="500"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// ── Constants ──
const W = canvas.width;
const H = canvas.height;
const GROUND_Y = H - 60;
const GRAVITY = 0.55;
const PLAYER_SPEED = 5.5;
const JUMP_FORCE = -13;
const WALL_CLIMB_SPEED = 4.5;

// ── Game State ──
let state = 'menu'; // menu | playing | won | dead
let cameraX = 0;
let levelWidth = 4000;
let particles = [];
let shakeTimer = 0;
let restartCooldown = 0;

// ── Input ──
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if ((e.code === 'Space' || e.code === 'Enter') && state !== 'playing') {
    if (restartCooldown <= 0) startGame();
  }
});
window.addEventListener('keyup', e => keys[e.code] = false);

// ── Player ──
let player = createPlayer();
function createPlayer() {
  return {
    x: 80, y: GROUND_Y - 36,
    w: 24, h: 36,
    vx: 0, vy: 0,
    onGround: false,
    onWall: false,
    wallDir: 0, // -1 left, 1 right
    climbingBigWall: false,
    jumpBuffer: 0,
    coyoteTime: 0,
    facing: 1,
    runFrame: 0,
    runTimer: 0,
    alive: true,
    won: false,
    trail: []
  };
}

// ── Level Elements ──
let walls = [];
let guards = [];
let bigWall = null;
let decorations = [];

function buildLevel() {
  walls = [];
  guards = [];
  decorations = [];

  // Small walls to jump over
  const wallPositions = [400, 800, 1300, 1800, 2400, 3000];
  wallPositions.forEach((x, i) => {
    const h = 40 + Math.random() * 25;
    walls.push({ x, y: GROUND_Y - h, w: 30, h, color: '#886644' });
  });

  // Some platforms
  const platforms = [
    { x: 500, y: GROUND_Y - 100, w: 80 },
    { x: 1000, y: GROUND_Y - 110, w: 100 },
    { x: 1400, y: GROUND_Y - 90, w: 70 },
    { x: 1900, y: GROUND_Y - 120, w: 90 },
    { x: 2300, y: GROUND_Y - 100, w: 80 },
    { x: 2900, y: GROUND_Y - 130, w: 100 },
  ];
  platforms.forEach(p => {
    walls.push({ x: p.x, y: p.y, w: p.w, h: 14, color: '#666', isPlatform: true });
  });

  // Guards patrolling
  const guardSpots = [
    { x: 600, range: 80 },
    { x: 1100, range: 90 },
    { x: 1600, range: 80 },
    { x: 2200, range: 90 },
    { x: 2800, range: 80 },
  ];
  guardSpots.forEach(g => {
    guards.push({
      x: g.x, y: GROUND_Y - 40,
      w: 28, h: 40,
      startX: g.x,
      range: g.range,
      speed: 0.8 + Math.random() * 0.5,
      dir: Math.random() > 0.5 ? 1 : -1,
      alert: false,
      alertTimer: 0,
      frame: 0,
      frameTimer: 0,
    });
  });

  // THE BIG WALL at the end
  bigWall = {
    x: levelWidth - 200,
    y: GROUND_Y - 220,
    w: 50,
    h: 220,
  };

  // Background decorations
  for (let i = 0; i < 60; i++) {
    decorations.push({
      x: Math.random() * levelWidth,
      y: GROUND_Y - Math.random() * 20,
      type: Math.random() > 0.5 ? 'grass' : 'rock',
      size: 3 + Math.random() * 6,
    });
  }
}

function startGame() {
  player = createPlayer();
  buildLevel();
  particles = [];
  cameraX = 0;
  state = 'playing';
  restartCooldown = 30;
}

// ── Collision ──
function rectsOverlap(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

// ── Particles ──
function spawnParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 1) * 5,
      life: 30 + Math.random() * 30,
      color,
      size: 2 + Math.random() * 3,
    });
  }
}

// ── Update ──
function update() {
  if (restartCooldown > 0) restartCooldown--;
  if (shakeTimer > 0) shakeTimer--;

  if (state !== 'playing') return;

  const p = player;

  // Input
  const left = keys['ArrowLeft'] || keys['KeyA'];
  const right = keys['ArrowRight'] || keys['KeyD'];
  const up = keys['ArrowUp'] || keys['KeyW'] || keys['Space'];

  // Horizontal movement
  if (left) { p.vx = -PLAYER_SPEED; p.facing = -1; }
  else if (right) { p.vx = PLAYER_SPEED; p.facing = 1; }
  else { p.vx *= 0.7; }

  // Jump buffer & coyote time
  if (up) p.jumpBuffer = 8;
  else p.jumpBuffer--;

  if (p.onGround) p.coyoteTime = 6;
  else p.coyoteTime--;

  // Jump
  if (p.jumpBuffer > 0 && p.coyoteTime > 0) {
    p.vy = JUMP_FORCE;
    p.jumpBuffer = 0;
    p.coyoteTime = 0;
    p.onGround = false;
    spawnParticles(p.x + p.w / 2, p.y + p.h, '#ccc', 5);
  }

  // Wall jump (off small walls)
  if (p.jumpBuffer > 0 && p.onWall && !p.onGround) {
    p.vy = JUMP_FORCE * 0.9;
    p.vx = -p.wallDir * 6;
    p.jumpBuffer = 0;
    p.onWall = false;
    spawnParticles(p.x + p.w / 2, p.y + p.h / 2, '#aaa', 4);
  }

  // Climb big wall
  if (bigWall && p.onWall && rectsOverlap(
    { x: p.x - 4, y: p.y, w: p.w + 8, h: p.h },
    bigWall
  )) {
    p.climbingBigWall = true;
    if (up) {
      p.vy = -WALL_CLIMB_SPEED;
      p.y += p.vy;
      spawnParticles(p.x + p.w / 2, p.y + p.h, '#aa8866', 1);
    } else {
      p.vy = 0.5; // slide slowly
    }
  } else {
    p.climbingBigWall = false;
  }

  // Gravity
  if (!p.climbingBigWall) {
    p.vy += GRAVITY;
    if (p.onWall && p.vy > 1.5) p.vy = 1.5; // wall slide
  }

  // Move
  p.x += p.vx;
  p.y += p.vy;

  // Collisions
  p.onGround = false;
  p.onWall = false;
  p.wallDir = 0;

  // Ground
  if (p.y + p.h >= GROUND_Y) {
    p.y = GROUND_Y - p.h;
    p.vy = 0;
    p.onGround = true;
  }

  // Walls & platforms
  const allSolids = [...walls, bigWall].filter(Boolean);
  for (const wall of allSolids) {
    if (!rectsOverlap(p, wall)) continue;

    // Resolve collision
    const overlapLeft = (p.x + p.w) - wall.x;
    const overlapRight = (wall.x + wall.w) - p.x;
    const overlapTop = (p.y + p.h) - wall.y;
    const overlapBottom = (wall.y + wall.h) - p.y;

    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

    if (minOverlap === overlapTop && p.vy >= 0) {
      p.y = wall.y - p.h;
      p.vy = 0;
      p.onGround = true;
    } else if (minOverlap === overlapBottom && p.vy < 0 && !wall.isPlatform) {
      p.y = wall.y + wall.h;
      p.vy = 0;
    } else if (minOverlap === overlapLeft && !wall.isPlatform) {
      p.x = wall.x - p.w;
      p.onWall = true;
      p.wallDir = 1;
    } else if (minOverlap === overlapRight && !wall.isPlatform) {
      p.x = wall.x + wall.w;
      p.onWall = true;
      p.wallDir = -1;
    }
  }

  // Win condition: player goes over the big wall
  if (bigWall && p.x > bigWall.x + bigWall.w && p.y < bigWall.y + 40) {
    state = 'won';
    p.won = true;
    spawnParticles(p.x, p.y, '#ffdd44', 40);
    spawnParticles(p.x, p.y, '#ff6644', 30);
    restartCooldown = 60;
  }

  // Bounds
  if (p.x < 0) p.x = 0;

  // Animation
  if (Math.abs(p.vx) > 0.5 && p.onGround) {
    p.runTimer++;
    if (p.runTimer > 6) { p.runTimer = 0; p.runFrame = (p.runFrame + 1) % 4; }
  } else {
    p.runFrame = 0;
  }

  // Trail
  if (Math.abs(p.vx) > 2 || Math.abs(p.vy) > 2) {
    p.trail.push({ x: p.x + p.w / 2, y: p.y + p.h / 2, life: 10 });
  }
  p.trail = p.trail.filter(t => { t.life--; return t.life > 0; });

  // ── Guards ──
  for (const g of guards) {
    // Patrol
    g.x += g.speed * g.dir;
    if (g.x < g.startX - g.range || g.x > g.startX + g.range) {
      g.dir *= -1;
    }

    // Animation
    g.frameTimer++;
    if (g.frameTimer > 8) { g.frameTimer = 0; g.frame = (g.frame + 1) % 4; }

    // Alert if player nearby
    const dist = Math.abs(p.x - g.x);
    if (dist < 120) {
      g.alert = true;
      g.alertTimer = 40;
      // Chase player
      if (p.x < g.x) g.dir = -1;
      else g.dir = 1;
      g.speed = 1.5;
    } else {
      if (g.alertTimer > 0) g.alertTimer--;
      else {
        g.alert = false;
        g.speed = 0.8 + Math.random() * 0.3;
      }
    }

    // Kill player on touch
    if (rectsOverlap(p, g)) {
      state = 'dead';
      p.alive = false;
      shakeTimer = 15;
      spawnParticles(p.x + p.w / 2, p.y + p.h / 2, '#ff4444', 20);
      restartCooldown = 40;
    }
  }

  // Camera
  const targetCamX = p.x - W / 3;
  cameraX += (targetCamX - cameraX) * 0.08;
  if (cameraX < 0) cameraX = 0;
  if (cameraX > levelWidth - W) cameraX = levelWidth - W;

  // Particles
  particles = particles.filter(pt => {
    pt.x += pt.vx;
    pt.y += pt.vy;
    pt.vy += 0.15;
    pt.life--;
    pt.size *= 0.97;
    return pt.life > 0;
  });
}

// ── Draw ──
function draw() {
  const shake = shakeTimer > 0 ? (Math.random() - 0.5) * 6 : 0;
  ctx.save();
  ctx.translate(shake, shake);

  // Sky gradient
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  skyGrad.addColorStop(0, '#1a1a3e');
  skyGrad.addColorStop(0.6, '#2d1f4e');
  skyGrad.addColorStop(1, '#0d0d1a');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);

  // Stars
  ctx.fillStyle = '#ffffff44';
  for (let i = 0; i < 50; i++) {
    const sx = ((i * 137 + 50) % W + (cameraX * 0.05) % W) % W;
    const sy = (i * 97 + 20) % (GROUND_Y - 50);
    ctx.fillRect(sx, sy, 1.5, 1.5);
  }

  // Moon
  ctx.fillStyle = '#ffeecc22';
  ctx.beginPath();
  ctx.arc(W - 120 + cameraX * 0.02, 80, 40, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#ffeedd44';
  ctx.beginPath();
  ctx.arc(W - 120 + cameraX * 0.02, 80, 35, 0, Math.PI * 2);
  ctx.fill();

  // Background buildings (parallax)
  ctx.fillStyle = '#1a1a2e';
  for (let i = 0; i < 15; i++) {
    const bx = i * 200 - (cameraX * 0.2) % 200;
    const bh = 60 + (i * 43) % 80;
    ctx.fillRect(bx, GROUND_Y - bh, 50 + (i * 17) % 40, bh);
    // Windows
    ctx.fillStyle = '#ffdd6622';
    for (let wy = GROUND_Y - bh + 10; wy < GROUND_Y - 10; wy += 18) {
      for (let wx = bx + 8; wx < bx + 50 + (i * 17) % 40 - 8; wx += 14) {
        if (Math.random() > 0.3) ctx.fillRect(wx, wy, 6, 8);
      }
    }
    ctx.fillStyle = '#1a1a2e';
  }

  ctx.save();
  ctx.translate(-cameraX, 0);

  // Ground
  ctx.fillStyle = '#2a2a2a';
  ctx.fillRect(0, GROUND_Y, levelWidth, H - GROUND_Y);
  ctx.fillStyle = '#3a3a3a';
  ctx.fillRect(0, GROUND_Y, levelWidth, 3);

  // Ground detail
  ctx.fillStyle = '#333';
  for (let i = 0; i < levelWidth; i += 20) {
    ctx.fillRect(i, GROUND_Y + 8, 12, 2);
  }

  // Decorations
  for (const d of decorations) {
    if (d.type === 'grass') {
      ctx.fillStyle = '#2d4a2d';
      ctx.fillRect(d.x, d.y - d.size, 2, d.size);
      ctx.fillRect(d.x - 2, d.y - d.size + 2, 2, d.size - 2);
      ctx.fillRect(d.x + 2, d.y - d.size + 3, 2, d.size - 3);
    } else {
      ctx.fillStyle = '#444';
      ctx.fillRect(d.x, d.y - d.size / 2, d.size, d.size / 2);
    }
  }

  // Walls
  for (const wall of walls) {
    if (wall.isPlatform) {
      ctx.fillStyle = '#556';
      ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
      ctx.fillStyle = '#778';
      ctx.fillRect(wall.x, wall.y, wall.w, 3);
    } else {
      // Brick pattern
      ctx.fillStyle = wall.color || '#886644';
      ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
      ctx.strokeStyle = '#66442244';
      ctx.lineWidth = 1;
      for (let by = wall.y; by < wall.y + wall.h; by += 10) {
        ctx.beginPath();
        ctx.moveTo(wall.x, by);
        ctx.lineTo(wall.x + wall.w, by);
        ctx.stroke();
        const offset = ((by - wall.y) / 10) % 2 === 0 ? 0 : wall.w / 2;
        ctx.beginPath();
        ctx.moveTo(wall.x + offset, by);
        ctx.lineTo(wall.x + offset, by + 10);
        ctx.stroke();
      }
      // Top highlight
      ctx.fillStyle = '#aa886644';
      ctx.fillRect(wall.x, wall.y, wall.w, 3);
    }
  }

  // Big wall
  if (bigWall) {
    const bw = bigWall;
    // Main wall
    const wallGrad = ctx.createLinearGradient(bw.x, bw.y, bw.x + bw.w, bw.y);
    wallGrad.addColorStop(0, '#555');
    wallGrad.addColorStop(0.5, '#777');
    wallGrad.addColorStop(1, '#555');
    ctx.fillStyle = wallGrad;
    ctx.fillRect(bw.x, bw.y, bw.w, bw.h);

    // Bricks
    ctx.strokeStyle = '#44444466';
    ctx.lineWidth = 1;
    for (let by = bw.y; by < bw.y + bw.h; by += 16) {
      ctx.beginPath();
      ctx.moveTo(bw.x, by);
      ctx.lineTo(bw.x + bw.w, by);
      ctx.stroke();
      const offset = ((by - bw.y) / 16) % 2 === 0 ? 0 : bw.w / 2;
      ctx.beginPath();
      ctx.moveTo(bw.x + offset, by);
      ctx.lineTo(bw.x + offset, by + 16);
      ctx.stroke();
    }

    // Top
    ctx.fillStyle = '#888';
    ctx.fillRect(bw.x - 5, bw.y - 8, bw.w + 10, 12);

    // "CLIMB ME" text
    ctx.fillStyle = '#ffcc44';
    ctx.font = 'bold 11px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('▲ CLIMB ▲', bw.x + bw.w / 2, bw.y + bw.h / 2);

    // Arrow
    ctx.fillStyle = '#ffcc4466';
    for (let ay = bw.y + 40; ay < bw.y + bw.h - 40; ay += 30) {
      ctx.beginPath();
      ctx.moveTo(bw.x + bw.w / 2, ay - 8);
      ctx.lineTo(bw.x + bw.w / 2 - 6, ay);
      ctx.lineTo(bw.x + bw.w / 2 + 6, ay);
      ctx.fill();
    }

    // "FREEDOM" sign on other side
    ctx.fillStyle = '#44ff4488';
    ctx.font = 'bold 14px monospace';
    ctx.fillText('★ FREEDOM ★', bw.x + bw.w + 60, bw.y + bw.h - 20);
  }

  // Guards
  for (const g of guards) {
    const gx = g.x;
    const gy = g.y;

    // Shadow
    ctx.fillStyle = '#00000044';
    ctx.fillRect(gx - 2, GROUND_Y - 4, g.w + 4, 4);

    // Body
    ctx.fillStyle = g.alert ? '#cc3333' : '#4455aa';
    const bounce = Math.sin(g.frame * Math.PI / 2) * 2;
    ctx.fillRect(gx + 4, gy + 8 - bounce, g.w - 8, g.h - 12);

    // Head
    ctx.fillStyle = g.alert ? '#dd4444' : '#5566bb';
    ctx.fillRect(gx + 6, gy - bounce, g.w - 12, 12);

    // Eyes
    ctx.fillStyle = '#fff';
    const eyeDir = g.dir > 0 ? 2 : -2;
    ctx.fillRect(gx + 8 + eyeDir, gy + 3 - bounce, 3, 3);
    ctx.fillRect(gx + 15 + eyeDir, gy + 3 - bounce, 3, 3);
    ctx.fillStyle = '#000';
    ctx.fillRect(gx + 9 + eyeDir, gy + 4 - bounce, 1.5, 1.5);
    ctx.fillRect(gx + 16 + eyeDir, gy + 4 - bounce, 1.5, 1.5);

    // Legs
    ctx.fillStyle = g.alert ? '#aa2222' : '#334499';
    const legOffset = Math.sin(g.frame * Math.PI / 2) * 4;
    ctx.fillRect(gx + 6, gy + g.h - 8, 5, 8 + legOffset);
    ctx.fillRect(gx + g.w - 11, gy + g.h - 8, 5, 8 - legOffset);

    // Alert indicator
    if (g.alert) {
      ctx.fillStyle = '#ff4444';
      ctx.font = 'bold 16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('!', gx + g.w / 2, gy - 10);
    }

    // Flashlight cone when alert
    if (g.alert) {
      ctx.fillStyle = '#ffff0011';
      ctx.beginPath();
      ctx.moveTo(gx + g.w / 2, gy + 10);
      if (g.dir > 0) {
        ctx.lineTo(gx + g.w + 80, gy - 20);
        ctx.lineTo(gx + g.w + 80, gy + 50);
      } else {
        ctx.lineTo(gx - 80, gy - 20);
        ctx.lineTo(gx - 80, gy + 50);
      }
      ctx.fill();
    }
  }

  // Player trail
  for (const t of player.trail) {
    const alpha = t.life / 10;
    ctx.fillStyle = `rgba(100, 200, 255, ${alpha * 0.3})`;
    ctx.fillRect(t.x - 3, t.y - 3, 6, 6);
  }

  // Player
  if (player.alive) {
    const p = player;
    const px = p.x;
    const py = p.y;

    // Shadow
    ctx.fillStyle = '#00000044';
    ctx.fillRect(px - 2, GROUND_Y - 3, p.w + 4, 3);

    // Body
    ctx.fillStyle = '#44ccff';
    const runBounce = p.onGround ? Math.sin(p.runFrame * Math.PI / 2) * 2 : 0;
    ctx.fillRect(px + 4, py + 10 - runBounce, p.w - 8, p.h - 14);

    // Head
    ctx.fillStyle = '#55ddff';
    ctx.fillRect(px + 4, py - runBounce, p.w - 8, 14);

    // Eyes
    ctx.fillStyle = '#fff';
    const pEyeDir = p.facing > 0 ? 2 : -2;
    ctx.fillRect(px + 6 + pEyeDir, py + 4 - runBounce, 3, 4);
    ctx.fillRect(px + 13 + pEyeDir, py + 4 - runBounce, 3, 4);
    ctx.fillStyle = '#222';
    ctx.fillRect(px + 7 + pEyeDir, py + 5 - runBounce, 1.5, 2);
    ctx.fillRect(px + 14 + pEyeDir, py + 5 - runBounce, 1.5, 2);

    // Legs
    ctx.fillStyle = '#339';
    const pLeg = p.onGround ? Math.sin(p.runFrame * Math.PI / 2) * 4 : 3;
    ctx.fillRect(px + 5, py + p.h - 6, 5, 6 + pLeg);
    ctx.fillRect(px + p.w - 10, py + p.h - 6, 5, 6 - pLeg);

    // Climbing indicator
    if (p.climbingBigWall) {
      ctx.fillStyle = '#ffcc4488';
      ctx.font = '10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('CLIMBING!', px + p.w / 2, py - 12);
    }

    // Wall sliding indicator
    if (p.onWall && !p.onGround && !p.climbingBigWall) {
      ctx.fillStyle = '#aaa';
      ctx.font = '8px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('wall slide', px + p.w / 2, py - 8);
    }
  }

  // Particles
  for (const pt of particles) {
    ctx.fillStyle = pt.color;
    ctx.globalAlpha = pt.life / 40;
    ctx.fillRect(pt.x - pt.size / 2, pt.y - pt.size / 2, pt.size, pt.size);
  }
  ctx.globalAlpha = 1;

  ctx.restore();

  // ── HUD ──
  // Distance indicator
  if (state === 'playing' && bigWall) {
    const dist = Math.max(0, bigWall.x - player.x);
    const pct = Math.min(1, 1 - dist / (levelWidth - 280));

    ctx.fillStyle = '#00000088';
    ctx.fillRect(W / 2 - 150, 12, 300, 20);
    ctx.fillStyle = '#333';
    ctx.fillRect(W / 2 - 148, 14, 296, 16);

    const barGrad = ctx.createLinearGradient(W / 2 - 148, 0, W / 2 + 148, 0);
    barGrad.addColorStop(0, '#44aaff');
    barGrad.addColorStop(1, '#44ff88');
    ctx.fillStyle = barGrad;
    ctx.fillRect(W / 2 - 148, 14, 296 * pct, 16);

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 11px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`WALL: ${Math.floor(pct * 100)}%`, W / 2, 27);

    // Controls reminder
    ctx.fillStyle = '#ffffff44';
    ctx.font = '10px monospace';
    ctx.fillText('← → Move  |  ↑/Space Jump  |  Hold ↑ to Climb Wall', W / 2, H - 10);
  }

  // ── Screens ──
  if (state === 'menu') {
    ctx.fillStyle = '#000000aa';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#f0c040';
    ctx.font = 'bold 36px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('WALL JUMPER', W / 2, H / 2 - 60);

    ctx.fillStyle = '#ccc';
    ctx.font = '16px monospace';
    ctx.fillText('Dodge the guards. Reach the wall. Climb over!', W / 2, H / 2 - 10);

    ctx.fillStyle = '#88ff88';
    ctx.font = 'bold 18px monospace';
    const blink = Math.sin(Date.now() / 300) > 0;
    if (blink) ctx.fillText('[ Press SPACE or ENTER to start ]', W / 2, H / 2 + 40);

    ctx.fillStyle = '#888';
    ctx.font = '12px monospace';
    ctx.fillText('Arrow Keys / WASD to move · Space / Up to jump', W / 2, H / 2 + 80);
  }

  if (state === 'won') {
    ctx.fillStyle = '#00000088';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#44ff88';
    ctx.font = 'bold 40px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('FREEDOM!', W / 2, H / 2 - 40);

    ctx.fillStyle = '#ffdd44';
    ctx.font = '18px monospace';
    ctx.fillText('You escaped over the wall!', W / 2, H / 2 + 10);

    ctx.fillStyle = '#aaa';
    ctx.font = '14px monospace';
    const blink = Math.sin(Date.now() / 300) > 0;
    if (blink) ctx.fillText('[ Press SPACE to play again ]', W / 2, H / 2 + 60);
  }

  if (state === 'dead') {
    ctx.fillStyle = '#00000088';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#ff4444';
    ctx.font = 'bold 36px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('CAUGHT!', W / 2, H / 2 - 30);

    ctx.fillStyle = '#ccc';
    ctx.font = '16px monospace';
    ctx.fillText('A guard got you!', W / 2, H / 2 + 10);

    ctx.fillStyle = '#aaa';
    ctx.font = '14px monospace';
    const blink = Math.sin(Date.now() / 300) > 0;
    if (blink) ctx.fillText('[ Press SPACE to retry ]', W / 2, H / 2 + 50);
  }

  ctx.restore();
}

// ── Game Loop ──
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
