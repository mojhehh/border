<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Flowey Attack Timeline Editor</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #111; color: #eee; font-family: monospace; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
#toolbar { background: #222; padding: 8px 16px; display: flex; align-items: center; gap: 12px; flex-wrap: wrap; border-bottom: 2px solid #444; }
#toolbar button { background: #444; color: #fff; border: 1px solid #666; padding: 6px 14px; cursor: pointer; font-family: monospace; font-size: 13px; border-radius: 4px; }
#toolbar button:hover { background: #555; }
#toolbar button.active { background: #ff4444; border-color: #ff6666; }
#toolbar label { font-size: 13px; color: #aaa; }
#toolbar input, #toolbar select { background: #333; color: #fff; border: 1px solid #555; padding: 4px 8px; font-family: monospace; font-size: 13px; border-radius: 3px; }
#toolbar input[type=range] { width: 120px; }
#toolbar input[type=number] { width: 50px; }
#main { flex: 1; display: flex; overflow: hidden; }
#canvas-wrap { flex: 1; position: relative; display: flex; align-items: center; justify-content: center; background: #000; }
canvas { cursor: crosshair; }
#sidebar { width: 320px; background: #1a1a1a; border-left: 2px solid #444; display: flex; flex-direction: column; }
#sidebar h3 { padding: 10px 14px; background: #222; border-bottom: 1px solid #444; font-size: 14px; }
#zone-list { flex: 1; overflow-y: auto; padding: 8px; }
.zone-item { background: #252525; border: 1px solid #444; border-radius: 4px; padding: 8px 10px; margin-bottom: 6px; font-size: 12px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
.zone-item:hover { border-color: #ff6666; }
.zone-item.selected { border-color: #ff4444; background: #331111; }
.zone-item .info { flex: 1; }
.zone-item .del { color: #ff4444; cursor: pointer; font-size: 16px; padding: 0 6px; }
.zone-item .del:hover { color: #ff8888; }
#timeline { height: 80px; background: #1a1a1a; border-top: 2px solid #444; position: relative; cursor: pointer; }
#timeline canvas { width: 100%; height: 100%; }
#controls { background: #222; padding: 8px 16px; display: flex; align-items: center; gap: 12px; border-top: 1px solid #444; font-size: 13px; }
#controls span { color: #aaa; }
#time-display { color: #ffcc44; font-weight: bold; font-size: 15px; min-width: 80px; }
#status { color: #88ff88; font-size: 12px; margin-left: auto; }
.help { font-size: 11px; color: #666; padding: 8px 14px; border-top: 1px solid #333; }
</style>
</head>
<body>

<div id="toolbar">
  <button onclick="document.getElementById('videoFile').click()">üìÇ Load Video</button>
  <input type="file" id="videoFile" accept="video/*" style="display:none">
  <span style="color:#444">|</span>
  <label>DMG: <input type="number" id="dmgInput" value="3" min="1" max="50"></label>
  <label>Duration (s): <input type="number" id="durInput" value="0.3" min="0.05" max="5" step="0.05"></label>
  <label>Type:
    <select id="typeInput">
      <option value="rect">Rectangle</option>
      <option value="beam">Full-Width Beam</option>
      <option value="vbeam">Full-Height Beam</option>
      <option value="circle">Circle</option>
    </select>
  </label>
  <label>Color:
    <select id="colorInput">
      <option value="#ff000088">Red</option>
      <option value="#ff880088">Orange</option>
      <option value="#ffff0088">Yellow</option>
      <option value="#8844ff88">Purple</option>
      <option value="#ffffff88">White</option>
    </select>
  </label>
  <span style="color:#444">|</span>
  <button onclick="exportJSON()">üíæ Export JSON</button>
  <button onclick="importJSON()">üì• Import JSON</button>
  <button onclick="previewAll()">‚ñ∂ Preview</button>
</div>

<div id="main">
  <div id="canvas-wrap">
    <canvas id="canvas" width="960" height="540"></canvas>
  </div>
  <div id="sidebar">
    <h3>Damage Zones (<span id="zoneCount">0</span>)</h3>
    <div id="zone-list"></div>
    <div class="help">
      Click+drag on video to draw zone<br>
      Arrow ‚Üê‚Üí = step 1 frame (hold Shift = 10)<br>
      Space = play/pause<br>
      Delete = remove selected zone<br>
      S = snap to current frame time
    </div>
  </div>
</div>

<div id="timeline">
  <canvas id="tlCanvas"></canvas>
</div>

<div id="controls">
  <button onclick="stepFrame(-10)">‚è™</button>
  <button onclick="stepFrame(-1)">‚óÄ</button>
  <button onclick="togglePlay()" id="playBtn">‚ñ∂ Play</button>
  <button onclick="stepFrame(1)">‚ñ∂</button>
  <button onclick="stepFrame(10)">‚è©</button>
  <span id="time-display">0.000s</span>
  <span>/ <span id="duration-display">0.000s</span></span>
  <input type="range" id="seekBar" min="0" max="1000" value="0" style="flex:1; min-width:200px;">
  <span id="status">Load a video to start</span>
</div>

<video id="video" style="display:none" preload="auto"></video>
<textarea id="jsonOutput" style="display:none"></textarea>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const video = document.getElementById('video');
const tlCanvas = document.getElementById('tlCanvas');
const tlCtx = tlCanvas.getContext('2d');
const seekBar = document.getElementById('seekBar');

let zones = []; // {time, duration, x, y, w, h, dmg, type, color, id}
let nextId = 1;
let selectedZone = null;
let drawing = false;
let drawStart = null;
let videoLoaded = false;
let playing = false;
let previewMode = false;

// Video dimensions mapping
let vw = 960, vh = 540; // canvas size
let scale = 1, offX = 0, offY = 0;

// Load video
document.getElementById('videoFile').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const url = URL.createObjectURL(file);
  video.src = url;
  video.load();
  video.addEventListener('loadedmetadata', () => {
    videoLoaded = true;
    document.getElementById('duration-display').textContent = video.duration.toFixed(3) + 's';
    seekBar.max = Math.floor(video.duration * 1000);
    fitCanvas();
    video.currentTime = 0;
    document.getElementById('status').textContent = file.name + ' loaded';
  }, { once: true });
  video.addEventListener('seeked', drawFrame);
  video.addEventListener('timeupdate', () => {
    if (playing) drawFrame();
  });
});

function fitCanvas() {
  const wrap = document.getElementById('canvas-wrap');
  const maxW = wrap.clientWidth - 20;
  const maxH = wrap.clientHeight - 20;
  const vRatio = video.videoWidth / video.videoHeight;
  let cw = maxW, ch = maxW / vRatio;
  if (ch > maxH) { ch = maxH; cw = maxH * vRatio; }
  canvas.width = Math.floor(cw);
  canvas.height = Math.floor(ch);
  vw = canvas.width;
  vh = canvas.height;
  drawFrame();
}

function drawFrame() {
  if (!videoLoaded) return;
  ctx.clearRect(0, 0, vw, vh);
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, vw, vh);
  ctx.drawImage(video, 0, 0, vw, vh);

  // Draw zones at current time
  const t = video.currentTime;
  for (const z of zones) {
    const inTime = t >= z.time && t <= z.time + z.duration;
    const alpha = inTime ? 0.5 : 0.15;
    const selected = z === selectedZone;

    ctx.save();
    if (z.type === 'beam') {
      ctx.fillStyle = z.color.slice(0, 7) + (inTime ? '88' : '33');
      ctx.fillRect(0, z.y, vw, z.h);
      if (selected) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(0, z.y, vw, z.h); }
    } else if (z.type === 'vbeam') {
      ctx.fillStyle = z.color.slice(0, 7) + (inTime ? '88' : '33');
      ctx.fillRect(z.x, 0, z.w, vh);
      if (selected) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(z.x, 0, z.w, vh); }
    } else if (z.type === 'circle') {
      const cx = z.x + z.w / 2, cy = z.y + z.h / 2, r = Math.max(z.w, z.h) / 2;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fillStyle = z.color.slice(0, 7) + (inTime ? '88' : '33');
      ctx.fill();
      if (selected) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke(); }
    } else {
      ctx.fillStyle = z.color.slice(0, 7) + (inTime ? '88' : '33');
      ctx.fillRect(z.x, z.y, z.w, z.h);
      if (selected) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(z.x, z.y, z.w, z.h); }
    }

    // Label
    if (inTime || selected) {
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 12px monospace';
      ctx.fillText(`${z.dmg}dmg @${z.time.toFixed(2)}s`, z.x + 4, z.y + 14);
    }
    ctx.restore();
  }

  // Update time display
  document.getElementById('time-display').textContent = video.currentTime.toFixed(3) + 's';
  seekBar.value = Math.floor(video.currentTime * 1000);

  // Timeline
  drawTimeline();

  if (playing) requestAnimationFrame(drawFrame);
}

function drawTimeline() {
  const w = tlCanvas.parentElement.clientWidth;
  const h = 80;
  tlCanvas.width = w;
  tlCanvas.height = h;
  tlCtx.fillStyle = '#1a1a1a';
  tlCtx.fillRect(0, 0, w, h);

  if (!videoLoaded) return;
  const dur = video.duration;

  // Time markers
  tlCtx.fillStyle = '#333';
  tlCtx.font = '10px monospace';
  const step = dur > 30 ? 5 : dur > 10 ? 2 : dur > 5 ? 1 : 0.5;
  for (let t = 0; t <= dur; t += step) {
    const x = (t / dur) * w;
    tlCtx.fillStyle = '#333';
    tlCtx.fillRect(x, 0, 1, h);
    tlCtx.fillStyle = '#666';
    tlCtx.fillText(t.toFixed(1) + 's', x + 3, 12);
  }

  // Zone markers
  for (const z of zones) {
    const x1 = (z.time / dur) * w;
    const x2 = ((z.time + z.duration) / dur) * w;
    const barW = Math.max(x2 - x1, 3);
    tlCtx.fillStyle = z === selectedZone ? '#ff4444' : z.color.slice(0, 7) + 'aa';
    tlCtx.fillRect(x1, 20, barW, 40);
    tlCtx.fillStyle = '#fff';
    tlCtx.font = '10px monospace';
    tlCtx.fillText(z.dmg + '', x1 + 2, 35);
  }

  // Playhead
  const px = (video.currentTime / dur) * w;
  tlCtx.fillStyle = '#ffcc44';
  tlCtx.fillRect(px - 1, 0, 3, h);
  tlCtx.beginPath();
  tlCtx.moveTo(px - 6, 0); tlCtx.lineTo(px + 6, 0); tlCtx.lineTo(px, 10);
  tlCtx.fillStyle = '#ffcc44';
  tlCtx.fill();
}

// Timeline click to seek
document.getElementById('timeline').addEventListener('click', e => {
  if (!videoLoaded) return;
  const rect = tlCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const pct = x / rect.width;
  video.currentTime = pct * video.duration;
  drawFrame();
});

// Seek bar
seekBar.addEventListener('input', () => {
  if (!videoLoaded) return;
  video.currentTime = parseInt(seekBar.value) / 1000;
  drawFrame();
});

// Drawing zones on canvas
canvas.addEventListener('mousedown', e => {
  if (!videoLoaded) return;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);

  // Check if clicking existing zone
  const t = video.currentTime;
  for (let i = zones.length - 1; i >= 0; i--) {
    const z = zones[i];
    if (mx >= z.x && mx <= z.x + z.w && my >= z.y && my <= z.y + z.h) {
      selectedZone = z;
      renderZoneList();
      drawFrame();
      return;
    }
  }

  // Start drawing new zone
  drawing = true;
  drawStart = { x: mx, y: my };
  selectedZone = null;
});

canvas.addEventListener('mousemove', e => {
  if (!drawing || !drawStart) return;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);

  drawFrame();
  // Preview rectangle
  ctx.strokeStyle = '#ff4444';
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 5]);
  ctx.strokeRect(drawStart.x, drawStart.y, mx - drawStart.x, my - drawStart.y);
  ctx.setLineDash([]);
});

canvas.addEventListener('mouseup', e => {
  if (!drawing || !drawStart) return;
  drawing = false;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);

  let x = Math.min(drawStart.x, mx);
  let y = Math.min(drawStart.y, my);
  let w = Math.abs(mx - drawStart.x);
  let h = Math.abs(my - drawStart.y);

  if (w < 5 || h < 5) { drawStart = null; return; } // too small, ignore

  const type = document.getElementById('typeInput').value;
  const zone = {
    id: nextId++,
    time: parseFloat(video.currentTime.toFixed(3)),
    duration: parseFloat(document.getElementById('durInput').value),
    // Normalize to 0-1 range for game export (resolution independent)
    x: Math.round(x), y: Math.round(y), w: Math.round(w), h: Math.round(h),
    // Normalized coords (for export)
    nx: x / vw, ny: y / vh, nw: w / vw, nh: h / vh,
    dmg: parseInt(document.getElementById('dmgInput').value),
    type,
    color: document.getElementById('colorInput').value,
  };

  zones.push(zone);
  selectedZone = zone;
  zones.sort((a, b) => a.time - b.time);
  renderZoneList();
  drawFrame();
  drawStart = null;
  document.getElementById('status').textContent = `Zone added @ ${zone.time.toFixed(3)}s`;
});

// Keyboard controls
window.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

  if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
  else if (e.code === 'ArrowLeft') { e.preventDefault(); stepFrame(e.shiftKey ? -10 : -1); }
  else if (e.code === 'ArrowRight') { e.preventDefault(); stepFrame(e.shiftKey ? 10 : 1); }
  else if (e.code === 'Delete' || e.code === 'Backspace') {
    if (selectedZone) {
      zones = zones.filter(z => z !== selectedZone);
      selectedZone = null;
      renderZoneList();
      drawFrame();
    }
  }
  else if (e.code === 'KeyS' && selectedZone) {
    // Snap selected zone to current time
    selectedZone.time = parseFloat(video.currentTime.toFixed(3));
    zones.sort((a, b) => a.time - b.time);
    renderZoneList();
    drawFrame();
    document.getElementById('status').textContent = `Snapped to ${selectedZone.time.toFixed(3)}s`;
  }
});

function togglePlay() {
  if (!videoLoaded) return;
  playing = !playing;
  if (playing) { video.play(); drawFrame(); }
  else { video.pause(); }
  document.getElementById('playBtn').textContent = playing ? '‚è∏ Pause' : '‚ñ∂ Play';
}

function stepFrame(n) {
  if (!videoLoaded) return;
  playing = false;
  video.pause();
  document.getElementById('playBtn').textContent = '‚ñ∂ Play';
  // ~30fps step
  video.currentTime = Math.max(0, Math.min(video.duration, video.currentTime + n * (1 / 30)));
}

function previewAll() {
  if (!videoLoaded || zones.length === 0) return;
  video.currentTime = 0;
  playing = true;
  previewMode = true;
  video.play();
  document.getElementById('playBtn').textContent = '‚è∏ Pause';
  drawFrame();
}

// Zone list rendering
function renderZoneList() {
  const list = document.getElementById('zone-list');
  document.getElementById('zoneCount').textContent = zones.length;
  list.innerHTML = '';
  for (const z of zones) {
    const div = document.createElement('div');
    div.className = 'zone-item' + (z === selectedZone ? ' selected' : '');
    div.innerHTML = `
      <div class="info">
        <strong>${z.dmg}dmg</strong> @ ${z.time.toFixed(3)}s (${z.duration}s)
        <br><small>${z.type} [${Math.round(z.nx*100)}%, ${Math.round(z.ny*100)}%] ${Math.round(z.nw*100)}%√ó${Math.round(z.nh*100)}%</small>
      </div>
      <span class="del" data-id="${z.id}">‚úï</span>
    `;
    div.addEventListener('click', () => {
      selectedZone = z;
      video.currentTime = z.time;
      renderZoneList();
      drawFrame();
    });
    div.querySelector('.del').addEventListener('click', e => {
      e.stopPropagation();
      zones = zones.filter(zz => zz.id !== z.id);
      if (selectedZone === z) selectedZone = null;
      renderZoneList();
      drawFrame();
    });
    list.appendChild(div);
  }
}

// Export JSON ‚Äî this is what you give to Copilot
function exportJSON() {
  const out = zones.map(z => ({
    time: z.time,
    duration: z.duration,
    // Normalized 0-1 coords (resolution independent)
    x: parseFloat(z.nx.toFixed(4)),
    y: parseFloat(z.ny.toFixed(4)),
    w: parseFloat(z.nw.toFixed(4)),
    h: parseFloat(z.nh.toFixed(4)),
    dmg: z.dmg,
    type: z.type,
  }));

  const json = JSON.stringify(out, null, 2);

  // Copy to clipboard
  navigator.clipboard.writeText(json).then(() => {
    document.getElementById('status').textContent = `Exported ${zones.length} zones ‚Äî copied to clipboard!`;
  }).catch(() => {
    // Fallback: show in prompt
    prompt('Copy this JSON:', json);
  });

  // Also download as file
  const blob = new Blob([json], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'flowey-attack-timeline.json';
  a.click();
}

// Import JSON
function importJSON() {
  const input = prompt('Paste JSON timeline data:');
  if (!input) return;
  try {
    const data = JSON.parse(input);
    zones = data.map(d => ({
      id: nextId++,
      time: d.time,
      duration: d.duration,
      x: d.x * vw, y: d.y * vh, w: d.w * vw, h: d.h * vh,
      nx: d.x, ny: d.y, nw: d.w, nh: d.h,
      dmg: d.dmg,
      type: d.type || 'rect',
      color: '#ff000088',
    }));
    zones.sort((a, b) => a.time - b.time);
    selectedZone = null;
    renderZoneList();
    drawFrame();
    document.getElementById('status').textContent = `Imported ${zones.length} zones`;
  } catch (e) {
    alert('Invalid JSON: ' + e.message);
  }
}

// Resize handler
window.addEventListener('resize', () => { if (videoLoaded) fitCanvas(); });

// Initial draw
drawTimeline();
</script>
</body>
</html>
